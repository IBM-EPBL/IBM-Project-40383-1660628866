# -*- coding: utf-8 -*-
"""ADS_WaterQualityPrediction_Final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XuAKvroTOVjJUDhBld0QEW6uIxMCM422

# **Essential Water Quality Analysis & Prediction**

Team members:


1.   Donifa Babu B M
2.   Eshwaran ABR
3.   Sadurthika M
4.   Vishnuram VR

# Upload dataset
"""

import numpy as np
import pandas as pd
import seaborn as sns 
import matplotlib.pyplot as plt
from sklearn.impute import SimpleImputer
from sklearn.neighbors import LocalOutlierFactor
from scipy.stats import probplot
from scipy.stats import zscore

# Importing the dataset
df = pd.read_csv("water_dataX.csv", encoding= 'unicode_escape')
# Selecting 1900 samples, because samples having indices greater than 1900 are not correct
df = df.iloc[0:1900, :]
df.shape

# Checking for datatypes of the dataset
df.dtypes

df.head()

df.info()

df.shape

df.describe()

"""# Handling missing values"""

# Converting object data type to numeric
def convert_to_numeric(df):
    num_col = df.shape[1]
    # Start from index 3
    for index in range(3, num_col):
        col_name = df.iloc[:, index].name
        df[col_name] = pd.to_numeric(df[col_name], errors="coerce")
    return df

df = convert_to_numeric(df)
df.dtypes

df.isnull().sum()

#Let us rename the columns for simplification
df = df.rename(columns={"D.O. (mg/l)": "DO", "CONDUCTIVITY (Âµmhos/cm)": "CO", "B.O.D. (mg/l)": "BOD", "NITRATENAN N+ NITRITENANN (mg/l)": "NI", "FECAL COLIFORM (MPN/100ml)": "Fec_col", "TOTAL COLIFORM (MPN/100ml)Mean": "Tot_col"})

df[ 'Temp' ].fillna(df[ 'Temp' ].mean(), inplace=True)
df['DO'].fillna(df['DO'].mean(), inplace=True)
df['PH'].fillna(df['PH'].mean(), inplace=True)
df['CO'].fillna(df['CO'].mean(), inplace=True)
df['BOD'].fillna(df['BOD'].mean(), inplace=True)
df['NI'].fillna(df[ 'NI'].mean(), inplace=True)
df['Tot_col'].fillna(df[ 'Tot_col'].mean(), inplace=True)

df.drop(columns=['Fec_col'])

df.columns

"""# Water Quality Index Calculation"""

#calulation of Ph

df[ 'npH' ]=df.PH. apply(lambda x: (100 if (8.5>=x>=7)
                                else(80 if (8.6>= x >=8.5) or (6.9>=x>=6.8)
                                    else(60 if (8.8>=x>=8.6) or (6.8>=x>=6.7)
                                        else(40 if (9>=x>=8.8) or (6.7>=x>=6.5)
                                            else 0)))))

#calculation of dissolved oxygen
df[ 'ndo' ]=df. DO. apply(lambda x: (100 if (x>=6)

else(80 if (6>=x>=5.1)
else(60 if (5>=x>=4.1)
else(40 if (4>=x>=3)
else 0) )) ) )

#calculation of total coliform
df[ 'nco' ]=df.Tot_col . apply(lambda x: (100 if (5>=x>=0)
else(80 if (50>=x>=5)

else(60 if (500>=x>=50)
else(40 if (10000>=x>=500)
else 0) ))) )

#calc of B.D.O

df[ 'nbdo' ]=df.BOD. apply(lambda x: (100 if (3>=x>=0)
else(80 if (6>=x>=3)

else(60 if (80>=x>=6)
else(40 if (125>=x>=80)
else 0)))) )

#calculation of electrical conductivity
df[ 'nec' ]=df.CO. apply (lambda x: (100 if (75>=x>=0)
else(80 if (150>=x>=75)

else(60 if (225>=x>=150)
else(40 if (300>=x>=225)
else 0))) ) )

#Calulation of nitrate
df[ 'nna' ]=df. NI. apply( lambda x: (100 if (20>=x>=0)
else(80 if (50>=x>=20)

else(60 if (100>=x>=50)
else(40 if (200>=x>=100)
else 0) ) ) ) )

# Calculate water quality index WQI
df[ 'wph' ]=df.npH * 0.165
df[ 'wdo' ]=df. ndo * 0.281

df[ 'wbdo' ]=df. nbdo * 0.234
df[ 'wec' ]=df.nec* 0.009
df[ 'wna' ]=df.nna * 0.028

df[ 'wco' ]=df.nco * 0.281
df[ 'wqi' ]=df.wph+df.wdo+df.wbdo+df.wec+df.wna+df.wco
df

#calculation overall wai for each year
average=df. groupby( 'year' ) [ 'wqi' ]. mean()
average . head()

"""# Visualization of Dataset"""

# PLotting PDFs of all the numeric attributes in the dataset

df = df.select_dtypes(exclude="object")

def plot_kde(df):
    n_col = df.shape[1]
    for index in range(n_col):
        col_index = df.iloc[:, index]
        fig, ax = plt.subplots(1,1, figsize=(7, 5))
        sns.kdeplot(data=df, x=col_index.name)
        
plot_kde(df)

"""# Classification based on WQI"""

df.shape

df['wqi']

df.columns

df.tail()

df.describe()

df.dtypes

"""# Prediction - 5 Algorithms
#  & Model Evaluation 
"""

pip install sklearn

#Splitting the data into dependent and independent variables
X= df[['year', 'DO', 'PH', 'CO','BOD','NI','Tot_col']]  
df['wqi']=df['wqi'].astype('int')
Y= df[['wqi']]

X.shape

Y.shape

from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.neural_network import MLPClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn import linear_model
from sklearn import metrics 
import math
from sklearn.metrics import mean_squared_error

X_train, X_test, Y_train, Y_test = train_test_split( X, Y,test_size=0.2, random_state=10)

#from sklearn.preprocessing import StandardScaler
#sc_X = StandardScaler()
#X_train = sc_X.fit_transform(X_train)
#X_test = sc_X.transform(X_test)

#{Decision Tree Model}
clf = DecisionTreeClassifier()
clf = clf.fit(X_train,Y_train)
clf_pred=clf.predict(X_test)
clf_accuracy=metrics.accuracy_score(Y_test,clf_pred)
print("1) Using Decision Tree Prediction, Accuracy is " + str(clf_accuracy))

#{K Neighbors Classifier}
knn = KNeighborsClassifier(n_neighbors=7)
knn=knn.fit(X_train,Y_train.values.ravel())
knn_pred=knn.predict(X_test)
knn_accuracy=metrics.accuracy_score(Y_test,knn_pred)
print ("2) Using K Neighbors Classifier Prediction, Accuracy is " + str(knn_accuracy))

#{using MLPClassifier}
mlpc = MLPClassifier()
mlpc.fit(X_train,Y_train.values.ravel())
mlpc_pred=mlpc.predict(X_test)
mlpc_accuracy=metrics.accuracy_score(Y_test,mlpc_pred)
print ("3) Using MLPC Classifier Prediction, Accuracy is " + str(mlpc_accuracy))

#{using MLPClassifier}
rfor = RandomForestClassifier()
rfor.fit(X_train,Y_train.values.ravel())
rfor_pred=rfor.predict(X_test)
rfor_accuracy=metrics.accuracy_score(Y_test,rfor_pred)
print ("4) Using RandomForest Classifier Prediction, Accuracy is " + str(rfor_accuracy))

#{using Linear Regression}
linreg=linear_model.LinearRegression()
linreg.fit(X_train,Y_train)
linreg_pred=rfor.predict(X_test)
linreg_accuracy=metrics.accuracy_score(Y_test,linreg_pred)
rmse = math.sqrt(mean_squared_error(Y_test,linreg_pred))
print ("5) Using Linear Regression Prediction, Accuracy is " + str(linreg_accuracy))

"""# Accuracy found maximum in RandomForest and Linear Regression



*   Decision Tree - 81.57%
*   KNN - 31.57%
*   MLPC classifier - 12.36%
*   Random Forest - 82.10%
*   Linear Regression - 82.10%

# Model Evaluation
"""

metrics.confusion_matrix(Y_test, rfor_pred)

print(metrics.classification_report(Y_test, rfor_pred))

"""
# Saving the model"""

pip install sklearn

# loading library
import pickle
# create an iterator object with write permission - model.pkl
with open('WaterQuality_RFModel.pkl', 'wb') as files:
    pickle.dump(rfor, files)

"""# Example"""

#Working out on input values
t=[[ 6.7,7.50,203.0,1.8965,0.100,27.0,2001]]
output=rfor.predict(t)
output

"""# END OF ANALYSIS"""